<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Map Visualization</title>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <!-- Create an element where the map will take place -->
    <svg id="my_dataviz" width="800" height="800" viewBox="0 0 800 800" preserveAspectRatio="xMidYMid meet"></svg>

    <script>
        // The svg
        const svg = d3.select("#my_dataviz"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

        // Map and projection
        const projection = d3.geoMercator()
            .scale(40000)  // Increased scale for better fit
            .center([103.8198, 1.3521])
            .translate([width / 2, height / 2]);

        const path = d3.geoPath().projection(projection);

        // Data and color scale
        const data = new Map();
        // const colorScale = d3.scaleThreshold()
        //     .domain([10000, 15000, 20000, 25000, 30000])
        //     .range(d3.schemeBlues[7]);
        const colorScale = d3.scaleSequential(d3.interpolateBlues)
            .domain([0, d3.max(Array.from(csvData.values()))]); // Use the max count from your data


        // Add error handling for data loading
        function handleError(error) {
            console.error("Data load error:", error);
            alert("There was an error loading the data. Check the console for details.");
        }

        // Load external data and boot
        Promise.all([
            d3.json("singapore-region.geojson")
                .then((geoData) => { console.log("GeoJSON loaded successfully:", geoData); return geoData; })
                .catch(handleError),
            d3.csv("region.csv")
                .then((csvData) => {
                const data = new Map();
                // Process the CSV data and populate the data map
                csvData.forEach(d => {
                    data.set(d.region.trim(), +d.count); // Assuming 'region' and 'count' are the correct column names
                });
                console.log("CSV data loaded successfully:", data);
                return data; // Return the data map for further processing
                })
        ]).then(function ([geoData, csvData]) {

        // Draw the map
        svg.selectAll("path")
            .data(geoData.features)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("fill", function (d) {
                const regionName = d.properties.name; // Adjust based on your GeoJSON properties
                const value = csvData.get(regionName) || 0; // Get count from the Map
                return colorScale(value); // Use the color scale based on the value
            })
            .style("stroke", "#333")
            .style("stroke-width", "1px")
            .attr("class", "region")
            .style("opacity", 1);

        // Add text labels for each region
        svg.selectAll("text")
            .data(geoData.features)
            .enter()
            .append("text")
            .attr("transform", function(d) {
                return "translate(" + path.centroid(d) + ")"; // Position the text at the centroid of each region
            })
            .attr("dy", ".35em") // Vertically align the text
            .text(function(d) {
                const regionName = d.properties.shape1; // 
                const value = csvData.get(regionName) || 0; // Get count from the Map
                console.log("Region:", regionName, "Count:", value);
                return regionName + ": " + value; // Show region name and population
            })
            .attr("font-size", "10px") // Adjust font size as needed
            .attr("fill", "black"); // Set text color

            // let topo = loadData[0];

            // if (!topo || !topo.features) {
            //     console.error("GeoJSON file doesn't have valid features.");
            //     alert("GeoJSON features are invalid.");
            //     return;
            // }

            // let mouseOver = function (d) {
            //     d3.selectAll(".region")
            //         .transition()
            //         .duration(200)
            //         .style("opacity", .5);
            //     d3.select(this)
            //         .transition()
            //         .duration(200)
            //         .style("opacity", 1);
            // };

            // let mouseLeave = function (d) {
            //     d3.selectAll(".region")
            //         .transition()
            //         .duration(200)
            //         .style("opacity", .8);
            //     d3.select(this)
            //         .transition()
            //         .duration(200);
            // };

            // const svg = d3.select("#map")
            // .append("svg")
            // .attr("width", width)
            // .attr("height", height);

            // svg.selectAll("path")
            // .data(data.features)
            // .enter()
            // .append("path")
            // .attr("d", pathGenerator)
            // .style("fill", "steelblue")
            // .style("stroke", "white");

            // // Draw the map
            // svg.append("g")
            //     .selectAll("path")
            //     .data(topo.features)
            //     .enter()
            //     .append("path")
            //     .attr("d", path)
            //     // Set the color of each region based on the customer count
            //     .attr("fill", function (d) {
            //         const regionName = d.properties.shape1;
            //         const value = data.get(regionName) || 0;
            //         console.log("Region:", regionName, "Count:", value);
            //         return colorScale(value);
            //     })
            //     .style("stroke", "#333")  // Add borders for better visibility
            //     .style("stroke-width", "1px")  // Ensure borders are visible
            //     .attr("class", "region")
            //     .style("opacity", .8)
            //     // .on("mouseover", mouseOver)
            //     // .on("mouseleave", mouseLeave);
        }).catch(function (error) {
            console.error("Error loading data:", error); // Log errors
        });
    </script>
</body>
</html>
